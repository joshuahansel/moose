//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include "ResidualConvergence.h"
#include "FEProblemBase.h"
#include "PetscSupport.h"
#include "Executioner.h"
#include "PerfGraphInterface.h"
#include "NonlinearSystemBase.h"
#include "ActionWarehouse.h"

// PETSc includes
#include <petscsnes.h>
#include <petscksp.h>
#include <petscdm.h>

// PetscDMMoose include
#include "PetscDMMoose.h"

registerMooseObject("MooseApp", ResidualConvergence);

InputParameters
ResidualConvergence::validParams()
{
  InputParameters params = Convergence::validParams();
  params += FEProblemSolve::feProblemDefaultConvergenceParams();

  params.addClassDescription(
      "Checks convergence based on absolute and relative error of the residual.");

  return params;
}

ResidualConvergence::ResidualConvergence(const InputParameters & parameters)
  : Convergence(parameters),
    _fe_problem(*getCheckedPointerParam<FEProblemBase *>("_fe_problem_base")),
    _nl_abs_tol(getParam<Real>("nl_abs_tol")),
    _nl_rel_tol(getParam<Real>("nl_rel_tol")),
    _nl_rel_step_tol(getParam<Real>("nl_rel_step_tol")),
    _nl_abs_div_tol(getParam<Real>("nl_abs_div_tol")),
    _nl_rel_div_tol(getParam<Real>("nl_div_tol")),
    _div_threshold(std::numeric_limits<Real>::max()),
    _nl_max_its(getParam<unsigned int>("nl_max_its")),
    _nl_forced_its(getParam<unsigned int>("nl_forced_its")),
    _nl_max_funcs(getParam<unsigned int>("nl_max_funcs")),
    _nl_max_pingpong(getParam<unsigned int>("n_max_nonlinear_pingpong")),
    _nl_current_pingpong(0)
{
}

bool
ResidualConvergence::checkRelativeConvergence(const PetscInt /*it*/,
                                              const Real fnorm,
                                              const Real ref_norm,
                                              const Real rel_tol,
                                              const Real /*abs_tol*/,
                                              std::ostringstream & oss)
{
  if (fnorm <= ref_norm * rel_tol)
  {
    oss << "Converged due to function norm " << fnorm << " < relative tolerance (" << rel_tol
        << ")\n";
    return true;
  }
  else
    return false;
}

Convergence::MooseConvergenceStatus
ResidualConvergence::checkConvergence(unsigned int iter)
{
  TIME_SECTION(_perfid_check_convergence);

  NonlinearSystemBase & system = _fe_problem.currentNonlinearSystem();
  MooseConvergenceStatus status = MooseConvergenceStatus::ITERATING;

  // Needed by ResidualReferenceConvergence
  nonlinearConvergenceSetup();

  SNES snes = system.getSNES();

  PetscErrorCode ierr;

  // ||u||
  PetscReal xnorm;
  ierr = SNESGetSolutionNorm(snes, &xnorm);
  CHKERRABORT(_fe_problem.comm().get(), ierr);

  // ||r||
  PetscReal fnorm;
  ierr = SNESGetFunctionNorm(snes, &fnorm);
  CHKERRABORT(_fe_problem.comm().get(), ierr);

  // ||du||
  PetscReal snorm;
  ierr = SNESGetUpdateNorm(snes, &snorm);
  CHKERRABORT(_fe_problem.comm().get(), ierr);

  // Get current number of function evaluations done by SNES
  PetscInt nfuncs;
  ierr = SNESGetNumberFunctionEvals(snes, &nfuncs);
  CHKERRABORT(_fe_problem.comm().get(), ierr);

#if !PETSC_VERSION_LESS_THAN(3, 8, 4)
  PetscBool force_iteration = PETSC_FALSE;
  ierr = SNESGetForceIteration(snes, &force_iteration);
  CHKERRABORT(_fe_problem.comm().get(), ierr);

  // if PETSc says to force iteration, then force at least one iteration
  if (force_iteration && !(_nl_forced_its))
    _nl_forced_its = 1;

  // if specified here to force iteration, but PETSc doesn't know, tell it
  if (!force_iteration && (_nl_forced_its))
  {
    ierr = SNESSetForceIteration(snes, PETSC_TRUE);
    CHKERRABORT(_fe_problem.comm().get(), ierr);
  }
#endif

  // See if SNESSetFunctionDomainError() has been called.  Note:
  // SNESSetFunctionDomainError() and SNESGetFunctionDomainError()
  // were added in different releases of PETSc.
  PetscBool domainerror;
  ierr = SNESGetFunctionDomainError(snes, &domainerror);
  CHKERRABORT(_fe_problem.comm().get(), ierr);
  if (domainerror)
    status = MooseConvergenceStatus::DIVERGED;

  Real fnorm_old;

  // This is the first residual before any iterations have been done,
  // but after preset BCs (if any) have been imposed on the solution
  // vector.  We save it, and use it to detect convergence if
  // compute_initial_residual_before_preset_bcs=false.
  if (iter == 0)
  {
    system.setInitialResidual(fnorm);
    // system.use_pre_SMO_residual = fnorm;
    //_initial_residual_after_preset_bcs = fnorm;
    fnorm_old = fnorm;
    _nl_current_pingpong = 0;
  }
  else
    fnorm_old = system._last_nl_rnorm;

  // Check for nonlinear residual ping-pong.
  // Ping-pong will always start from a residual increase
  if ((_nl_current_pingpong % 2 == 1 && !(fnorm > fnorm_old)) ||
      (_nl_current_pingpong % 2 == 0 && fnorm > fnorm_old))
    _nl_current_pingpong += 1;
  else
    _nl_current_pingpong = 0;

  std::ostringstream oss;
  if (fnorm != fnorm)
  {
    oss << "Failed to converge, function norm is NaN\n";
    status = MooseConvergenceStatus::DIVERGED;
  }
  else if ((iter >= _nl_forced_its) && fnorm < _nl_abs_tol)
  {
    oss << "Converged due to function norm " << fnorm << " < " << _nl_abs_tol << '\n';
    status = MooseConvergenceStatus::CONVERGED;
  }
  else if (nfuncs >= _nl_max_funcs)
  {
    oss << "Exceeded maximum number of function evaluations: " << nfuncs << " > " << _nl_max_funcs
        << '\n';
    status = MooseConvergenceStatus::DIVERGED;
  }
  else if ((iter >= _nl_forced_its) && iter && fnorm > system._last_nl_rnorm &&
           fnorm >= _div_threshold)
  {
    oss << "Nonlinear solve was blowing up!\n";
    status = MooseConvergenceStatus::DIVERGED;
  }
  if ((iter >= _nl_forced_its) && iter && status == MooseConvergenceStatus::ITERATING)
  {
    const auto ref_residual = system.referenceResidual();
    if (checkRelativeConvergence(iter, fnorm, ref_residual, _nl_rel_tol, _nl_abs_tol, oss))
      status = MooseConvergenceStatus::CONVERGED;
    else if (snorm < _nl_rel_step_tol * xnorm)
    {
      oss << "Converged due to small update length: " << snorm << " < " << _nl_rel_step_tol << " * "
          << xnorm << '\n';
      status = MooseConvergenceStatus::CONVERGED;
    }
    else if (_nl_rel_div_tol > 0 && fnorm > ref_residual * _nl_rel_div_tol)
    {
      oss << "Diverged due to relative residual " << ref_residual << " > divergence tolerance "
          << _nl_rel_div_tol << " * relative residual " << ref_residual << '\n';
      status = MooseConvergenceStatus::DIVERGED;
    }
    else if (_nl_abs_div_tol > 0 && fnorm > _nl_abs_div_tol)
    {
      oss << "Diverged due to residual " << fnorm << " > absolute divergence tolerance "
          << _nl_abs_div_tol << '\n';
      status = MooseConvergenceStatus::DIVERGED;
    }
    else if (_nl_current_pingpong > _nl_max_pingpong)
    {
      oss << "Diverged due to maximum nonlinear residual pingpong achieved" << '\n';
      status = MooseConvergenceStatus::DIVERGED;
    }
  }

  system._last_nl_rnorm = fnorm;
  system._current_nl_its = static_cast<unsigned int>(iter);

  std::string msg;
  msg = oss.str();
  if (_app.multiAppLevel() > 0)
    MooseUtils::indentMessage(_app.name(), msg);
  if (msg.length() > 0)
#if !PETSC_VERSION_LESS_THAN(3, 17, 0)
    ierr = PetscInfo(snes, "%s", msg.c_str());
#else
    ierr = PetscInfo(snes, msg.c_str());
#endif

  return status;
}
